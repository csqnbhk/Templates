#include"test.h"
int main()
{
	//非类型的类模版参数
	Stack<std::string> s_o;
	s_o.push("北京");
	s_o.push("上海");
	s_o.push("南京");
	s_o.push("杭州");


	s_o.push("深圳");
	s_o.elems_info();

	//非类型的函数模版参数
	cout << "::addvalue<int,7>(8)=" << ::addvalue<int, 7>(8) << endl;


	/*
	  小结：

	  1.非类型模版参数是有限制的，通常而言，它们可以是长整数（包括枚举值）或者指向
	    外部链接对象的指针。
	
	  2.浮点数，类对象和内部链接对象（例如string)是不许作为非类型模版参数的。
	*/


	/*************************************************************************************************
	
	                      编程技巧
	**************************************************************************************************/

	//Base<float> base;
	//Derived<int> subclass;

	///*subclass.foo();*/


	/*
	   小结：

	   1.如果要访问依赖于模版参数的类型名称，应该在类型名称前面添加关键字 typename 。

	   2.嵌套类和成员函数也可以是模版。针对于元素可以进行隐式类型转化的2个栈，可以实现通用的
	     赋值操作。然而，在这种情况下，类型检查还是存在的。

       3.赋值运算符的模版版本并没有取代缺省赋值运算符。

	   4.类模板也可以作为模版参数，称为模版的模版参数。

	   5.模版的模版参数必须精确地匹配，匹配是并不会考虑“模版的模版实参”的缺省模版实数。（例如std::queue的allocator)

	   6.通过显示调用缺省构造函数，可以确保模版的变量和成员函数都已经使用一个缺省值完成初始化，这种方法对内建类型的变量和成员也适用。

	   7.对于字符串，在实参推导过程中，当且仅当参数不是引用时，才会出现数组到指针（array_to_pointer)的类型转化（称为退化decay）。


	*/
	return 0;
}