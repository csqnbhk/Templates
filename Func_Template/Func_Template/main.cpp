#include"Function.h"
int main()
{

	//正常调用函数模版
	cout << "正常调用函数模版" << endl;
	int temp_int=::max(8, 5);
	cout << "max(8, 5)=" << temp_int << endl;

	double temp_double = ::max(9.1, 7.8);
	cout << "max(9.1, 7.8)=" << temp_double << endl;


	//实参的推导
	//::max(5, 7.2); error:两个参数类型不一样
	cout << "对实参进行参数的推导" << endl;
	cout << "1.对实参进行强制转化，max(static_cast<double>(5), 7.2)=" << ::max(static_cast<double>(5), 7.2) << endl;
	cout << "2.显示指定T的参数类型，:max<double>(8.8, 7)=" << ::max<double>(8.8, 7) << endl;
	cout << "3.两个参数可以具备不同的类型,template<typename T1,typename T2>,T1 const&max(T1 const&a,T2 const&b) "<< endl;


	//2.模版参数
   /*
   
     函数模版有两种类型的参数：
	 1.模版参数：位于函数模版名称的前面，在一对尖括号内部进行声明：
	 template<typename T> //T是模版参数


	 2.调用参数：位于函数模版名称之后，在一对圆括号内部进行声明：
	 ：：max(T const&a,T const&b) //a,b都是调用参数
   
   注意：你可以根据需要声明任意数量的模版参数。然而，在函数模版内部（这一点和类模版有区别），不能
         指定缺省的模版实参。例如，你可以定义一个“两个调用参数的类型可以不同的”max()模版
		 template<typename T1,typename T2>
		 T1 const max(T1 const &a,T2 const&b)
		 {
		  
		     return a>b?a:b;

		 }
        ...... 
		调用
		max(4,4.2)//OK,第一个参数定义了返回类型
		
		注意：在这个例子里，我们定义的返回类型必须为 T1 const,而不能为T1 const&,因为把第二个参数类型
	          转化为返回类型的过程中将会创建一个新的局部临时对象，这导致了你不能通过引用来返回结果。
			  （
                    对于那些作用域局部于函数内部的值，就不应该通过引用来返回该值，即使返回了一个指向
					该值的引用，当程序离开这个函数的作用域之后，该值将不在存在，该引用也不再有效。
			  )
   
   */


	//3.调用重载函数模版
	cout << "调用重载函数模版,max(8,13,9)=" << ::max(8, 13, 9);



	//4.小结
	/*
	  1.模版函数为不同的模版实参定义了一个函数家族。
	  
	  2.当你传递模版实参的时候，可以根据实参的类型来对函数模版进行实例化。

	  3.你可以显示指定模版参数。

	  4.你可以重载函数模版。

	  5.当重载函数模版的时候，把你的改变限制在：显示地指定模版参数。

	  6.一定要函数模版的所有重载版本的声明都位于他们被调用的位置之前。
	
	*/
	return 0;
}