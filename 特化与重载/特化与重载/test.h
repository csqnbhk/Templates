/*****************************************************************************

    该test.h头文件的作用：回顾一下模版的"特化与重载"
	author：Demon
	Time:2017/9/17

******************************************************************************/
#pragma once
#include<iostream>
using namespace std;
/*

12.1 当泛型代码不再适用的时候

     12.1.1 透明自定义
	     
		 1.C++模版提供了很多种透明的自定义函数模版和类模板的方法。对于函数模版，
		   我们可以通过重载机制实现。

		2.在其它条件都一样的情况下，重载解析规则会优先选择更加特殊的模版。

	 12.1.2 语义的透明性


12.2重载函数模版
  
    12.2.1 签名

	       1.只要具有不同的签名，两个函数就可以在用一个程序中同时存在。对签名定义如下：
		   /
		     1.非受限函数名称（或者产生自函数模版的这类名称）

			 2.函数名称所属的类作用域或者名字空间域；如果函数名称是具有内部链接的，还
			  包括该名称声明所在的翻译单元。
			 
			3.函数的const，volatile或者const volatile限定符（前提是它是一个具有这类限定符
			  的成员函数）。

			4.函数参数的类型（如果这个函数是产生自函数模版的，那么指的是模版参数被替换之前
			  的类型）。

			5.如果这个函数是产生自函数模版，那么包括它的返回类型。

			6.如果这个函数是产生自函数模版，那么包括模版参数和模版实参。

		   
	       /

		   template<typename T1,typename T2>
		   void f()
		   {
		      cout<<"f(T1,T2) called"<<endl;
		   }
		   template<typename T2,typename T1>
		   void f()
		   {
		      cout<<"f(T2,T1) called"<<endl;
		   }
		   int main()
		   {
		      f<char,char>('a','c');//错误，二重定义
		   }
		   注意：对于上面这种情况，只有这两个模版在不同的翻译单元时，它们两个实体才可以同时存在。
		         而且链接器也不会说存在重复定义，因为这两个实例化体的签名是不同的。

	12.2.2 重载的函数模版的局部排序
	        
			template<typename T>
			int f(T)                //（1）
			{
			   return 1;
			}
			
			template<typename T>
			int f(T*)             //（2）
			{
			return 2;
			}

		    int main()
			{

			  cout << f(0) << endl;       //（3）
	          cout << f((int*)0) << endl;  //(4)
			  return 0;
			}

			1.(3)c处的调用没有重载解析。
			2.（4）处的调用，两个模版都可以成功，于是就获得两个函数，即
			   f<int*>(int*)和f<int>(int*)
			特别注意：该例子不会产生二重定义，其它条件相同的时候，选择更加特殊的模版。

	12.2.3 正式的排序原则
            
			1.如果解析必须在两个特殊程度完全相同的模版中做出选择那么将不做任何决定，
			  也就是说，程序包含了一个二重定义。

			
	 
	12.2.4 模版和非模版
	       
		   1.函数模版也可以和非函数模版同时重载。当其它条件都是一样的时候，实际的函数
		    调用将会优先选择非函数模版。
			template<typename T>
			void f(T)
			{
			  cout<<" f(T) called"<<endl;
			}
			void f(int)
			{
			  cout<<f(int) called"<<endl;
			}

			int main()
			{
			   f(23); //会选择非函数模版（普通函数）调用。
			   return 0;
			}

12.3 显示特化

    12.3.1 全局的类模版特化
	      
		  1.类模版不能被重载，但是我们可以选择另一种替换机制来实现这种透明自定义类模版能力。
		   那就是"显示特化".(通常也叫做“全局特化”）

		   2.事实上，类模板和函数模版都是可以被全局特化的，而且类模板的成员（包括成员函数，
		    嵌入类，静态成员变量等，它们的定义可以位于类定义的外部）也可以被全局特化。

		   3.局部特化和全局特化有点类似，但是局部特化并没有替换所有的模版参数，也就是说，还有
		     某些参数实现依然保留在模版的（另一种）实现中。另外，在源代码中，全局特化和局部特化
			 都是显示的。全局特化和局部特化都没有引入一个全新的模版或者模版实例。它们只是在原来
			 的泛型（或者非特化）模版中隐式声明的实例提供另一种定义。这也是特区别于重载模版的关键
			 所在。

	12.3.2 全局的函数模版特化
	       
		   1.全局函数模版特化和类模版特化大体一致。唯一区别：
		    函数模版特化引入了重载和实参演绎这两个概念。

		   2.如果借助于实参演绎（用实参类型演绎声明中给出的参数类型）来确定模版的特化版本，那么
		    全局特化可以不用声明显示地模版实参。

		   3.全局函数模版特化不能包含缺省的实参值。然而，对于基本（即将被特化的）模版所指定的任何
		     缺省值，显示特化版本都可以应用这些缺省值。

             template<typename T>
			 int f(T,T x=88)
			 {

			    return x;
			 }

			 template<>
			 int f(int,int=23) //错误：不能包含缺省实参值
			 {
			   return -1;
			 }

			 template<typename T>
			 int f(int,int y)
			 {
			    return y*3;
			 }

           template<typename T>
           int g(T, T x = 23)
           {
	          return x;
           }

          //声明特化,为了避免重复定义，不把定义放在这里（把特化声明为内联函数，这种情况下就可以
          //把定义放在头文件里（其实是说应该把定义放在头文件中）。
           template<> int g(int, int y);

   
	12.3.3 全局成员特化
	     
		   1.除了成员模版之外，类模版的成员函数和普通的静态成员函数也可以被全局特化；
		     实现特化的语法会要求给每个外围类模版加上 template<>前缀。

		  2.尽管对于普通类的成员函数和静态成员变量而言，非定义的类外声明C++是不允许的，
		    但是如果是针对类模版的特化成员，该声明则是合法的。

			template<typename T>
			class S
			{
			   public:
			   static int code;
			};
			//定义的类外声明
		    template<>
			class S<int>::code=13;

			//下面声明合法
			template<>
			class S<bool>::code;

12.4 局部的类模版特化
    
	1.局部特化的实参必须和基本模版的相应参数在种类上（可以是类型，非类型或者模版）是匹配的。

	2.局部特化的参数列表不能具有缺省实参，但局部特化依然可以使用基本模版的缺省实参。

	3.局部特化的非类型实参只能是非类型值，或者是普通的非类型模版参数；而不能是更复杂的依赖
	  表达式。（诸如 2*N，其中N为模版参数）。

	4.局部特化的模版实参列表不能和基本模版的参列表完全相同。（不考虑重新命名）。

	注意：如果找到多个匹配的特化，编译器会选择最特殊的那一个。如果几个特殊化程度一样，
	      程序出现一个二重定义。

*/
/***********************************************************************/

#ifndef _TEST_H_
#define _TEST_H_


#endif//_TEST_H_





